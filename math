// ============================
// math.js - Ultimate Math Library
// Complejos, vectores, matrices, combinatoria, estadística, teoría de números
// ============================

// ----------------------------
// Constantes
// ----------------------------
const PI = Math.PI
const TAU = 2 * PI
const E = Math.E
const PHI = (1 + Math.sqrt(5)) / 2
const G = 6.67430e-11          // Gravedad
const c = 299792458            // Velocidad de la luz (m/s)

// ----------------------------
// Complejos
// ----------------------------
class Complex {
  constructor(re, im) {
    this.re = re
    this.im = im
  }

  add(other) {
    if (typeof other === 'number') other = new Complex(other, 0)
    return new Complex(this.re + other.re, this.im + other.im)
  }

  sub(other) {
    if (typeof other === 'number') other = new Complex(other, 0)
    return new Complex(this.re - other.re, this.im - other.im)
  }

  mul(other) {
    if (typeof other === 'number') other = new Complex(other, 0)
    return new Complex(
      this.re * other.re - this.im * other.im,
      this.re * other.im + this.im * other.re
    )
  }

  div(other) {
    if (typeof other === 'number') other = new Complex(other, 0)
    const denom = other.re * other.re + other.im * other.im
    return new Complex(
      (this.re * other.re + this.im * other.im) / denom,
      (this.im * other.re - this.re * other.im) / denom
    )
  }

  pow(n) {
    if (typeof n === 'number') {
      const r = abs(this) ** n
      const theta = arg(this) * n
      return new Complex(r * Math.cos(theta), r * Math.sin(theta))
    } else if (n instanceof Complex) {
      return exp(log(this).mul(n))
    }
  }

  zroot(n) {
    const r = Math.sqrt(this.re * this.re + this.im * this.im)
    const theta = Math.atan2(this.im, this.re)
    const roots = []
    for (let k = 0; k < n; k++) {
      const angle = (theta + 2 * PI * k) / n
      roots.push(new Complex(r ** (1 / n) * Math.cos(angle), r ** (1 / n) * Math.sin(angle)))
    }
    return roots
  }

  conjugate() {
    return new Complex(this.re, -this.im)
  }

  equals(other) {
    if (typeof other === 'number') other = new Complex(other, 0)
    return this.re === other.re && this.im === other.im
  }

  toString() {
    return this.im >= 0 ? `${this.re} + ${this.im}i` : `${this.re} - ${-this.im}i`
  }
}

const I = new Complex(0, 1)

// Funciones complejas
function abs(z) {
  return z instanceof Complex ? Math.sqrt(z.re * z.re + z.im * z.im) : Math.abs(z)
}

function arg(z) {
  return z instanceof Complex ? Math.atan2(z.im, z.re) : (z >= 0 ? 0 : Math.PI)
}

function conj(z) { return z instanceof Complex ? z.conjugate() : new Complex(z, 0) }
function exp(z) { 
  if (typeof z === 'number') return Math.exp(z)
  const e = Math.exp(z.re)
  return new Complex(e * Math.cos(z.im), e * Math.sin(z.im))
}
function log(z) { return z instanceof Complex ? new Complex(Math.log(abs(z)), arg(z)) : Math.log(z) }
function sqrt(z) { return z instanceof Complex ? z.zroot(2)[0] : Math.sqrt(z) }
function sin(z) { 
  if (typeof z === 'number') return Math.sin(z)
  return new Complex(Math.sin(z.re) * Math.cosh(z.im), Math.cos(z.re) * Math.sinh(z.im))
}
function cos(z) { 
  if (typeof z === 'number') return Math.cos(z)
  return new Complex(Math.cos(z.re) * Math.cosh(z.im), -Math.sin(z.re) * Math.sinh(z.im))
}
function tan(z) { return (z instanceof Complex ? sin(z).div(cos(z)) : Math.tan(z)) }
function sinh(z) { 
  if (typeof z === 'number') return Math.sinh(z)
  return new Complex(Math.sinh(z.re) * Math.cos(z.im), Math.cosh(z.re) * Math.sin(z.im))
}
function cosh(z) { 
  if (typeof z === 'number') return Math.cosh(z)
  return new Complex(Math.cosh(z.re) * Math.cos(z.im), Math.sinh(z.re) * Math.sin(z.im))
}
function tanh(z) { return (z instanceof Complex ? sinh(z).div(cosh(z)) : Math.tanh(z)) }

// Funciones de verificación de tipo
function inC(x) { return x instanceof Complex && x.re !== 0 && x.im !== 0 }
function inIm(x) { return x instanceof Complex && x.re === 0 && x.im !== 0 }
function inR(x) { return typeof x === 'number' || (x instanceof Complex && x.im === 0) }
function inZ(x) { return (typeof x === 'number' && x % 1 === 0) || (x instanceof Complex && x.im === 0 && x.re % 1 === 0) }

// ----------------------------
// Vectores 2D/3D
// ----------------------------
class Vec {
  constructor(x, y, z = 0) {
    this.x = x
    this.y = y
    this.z = z
  }

  add(v) { return new Vec(this.x + v.x, this.y + v.y, this.z + v.z) }
  sub(v) { return new Vec(this.x - v.x, this.y - v.y, this.z - v.z) }
  scale(s) { return new Vec(this.x * s, this.y * s, this.z * s) }
  dot(v) { return this.x * v.x + this.y * v.y + this.z * v.z }
  cross(v) { return new Vec(this.y*v.z - this.z*v.y, this.z*v.x - this.x*v.z, this.x*v.y - this.y*v.x) }
  norm() { return Math.sqrt(this.dot(this)) }
  normalize() { let n = this.norm(); return n === 0 ? new Vec(0,0,0) : this.scale(1/n) }
}

// ----------------------------
// Matrices
// ----------------------------
class Matrix {
  constructor(data) { this.data = data }
  static zeros(rows, cols) { return new Matrix(Array.from({length:rows},()=>Array(cols).fill(0))) }
  add(m) { return new Matrix(this.data.map((r,i)=>r.map((v,j)=>v + m.data[i][j]))) }
  sub(m) { return new Matrix(this.data.map((r,i)=>r.map((v,j)=>v - m.data[i][j]))) }
  mul(m) {
    let rows = this.data.length
    let cols = m.data[0].length
    let result = Array.from({length:rows},()=>Array(cols).fill(0))
    for (let i=0;i<rows;i++) for (let j=0;j<cols;j++) for (let k=0;k<this.data[0].length;k++) result[i][j] += this.data[i][k]*m.data[k][j]
    return new Matrix(result)
  }
}

// ----------------------------
// Teoría de números
// ----------------------------
function gcd(a,b){return b===0?a:gcd(b,a%b)}
function lcm(a,b){return Math.abs(a*b)/gcd(a,b)}
function factorial(n){return n<=1?1:n*factorial(n-1)}
function binomial(n,k){return factorial(n)/(factorial(k)*factorial(n-k))}
function primeFactors(n){let f=[],d=2;while(n>1){while(n%d===0){f.push(d);n/=d}d++;} return f}
function isPrime(n){if(n<2) return false; for(let i=2;i*i<=n;i++) if(n%i===0) return false; return true}
function generatePrimes(max){let sieve=Array(max+1).fill(true);sieve[0]=sieve[1]=false;let r=[];for(let p=2;p*p<=max;p++) if(sieve[p]) for(let i=p*p;i<=max;i+=p) sieve[i]=false; for(let i=2;i<=max;i++) if(sieve[i]) r.push(i); return r}
function generateGaussianPrimes(max){let r=[];for(let a=-max;a<=max;a++) for(let b=-max;b<=max;b++){if(a===0&&b===0) continue; if(isPrime(a*a+b*b)) r.push(new Complex(a,b))} return r}

// ----------------------------
// Estadística
// ----------------------------
function mean(arr){return arr.reduce((a,b)=>a+b,0)/arr.length}
function median(arr){let s=[...arr].sort((a,b)=>a-b);let n=s.length; return n%2?s[(n-1)/2]:(s[n/2-1]+s[n/2])/2}
function variance(arr){let m=mean(arr);return arr.reduce((a,b)=>a+(b-m)**2,0)/arr.length}
function std(arr){return Math.sqrt(variance(arr))}
function covariance(a,b){let ma=mean(a),mb=mean(b);return a.reduce((s,v,i)=>s+(v-ma)*(b[i]-mb),0)/a.length}
function correlation(a,b){return covariance(a,b)/(std(a)*std(b))}

// ----------------------------
// Exportaciones
// ----------------------------
export default {
  PI, TAU, E, PHI, G, c,
  Complex, I, inC, inIm, inR, inZ, abs, arg, conj, exp, log, sqrt, sin, cos, tan, sinh, cosh, tanh, pow,
  Vec, Matrix,
  gcd, lcm, factorial, binomial, primeFactors, isPrime, generatePrimes, generateGaussianPrimes,
  mean, median, variance, std, covariance, correlation
}
